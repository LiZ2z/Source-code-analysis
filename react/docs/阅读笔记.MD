一切始于`ReactDOM.render(element, container, callback)`。此方法在开发环境下会做一些安全校验，然后调用`legacyRenderSubtreeIntoContainer(null, element, container, false, callback)`。

#### `legacyRenderSubtreeIntoContainer(parentComponent, children, container, forceHydrate, callback)`

legacy 遗产？React 的文档上说明：

> 如果我们发现很多应用中必要的模式我们找不到一个完美的 API，我们会提供一个临时欠佳的 API，只要以后可以移除它并且方便后续的优化。

以 legacy 开头的命名可能就是代表这个意思。

这个函数同时被 `ReactDOM.render()` 和 `ReactDOM.unmountComponentAtNode()`调用，当被`ReactDOM.render()`调用时，`element`参数是一个有效的 React 元素，被`ReactDOM.unmountComponentAtNode()`调用时`element`参数的值为`null`。

1. (TODO: 仔细看)校验参数 container， `topLevelUpdateWarnings(container)`会对 container 进行校验, 例如是否在未使用 React api 情况下删除了 React 节点中的内容、不能用`ReactDOM.render`向已有 react 组件的节点中渲染内容、container 不能是 document.body

2. 判断 `container._reactRootContainer`（**Root**） 存不存在? 如果不存在 ，
   则通过`legacyCreateRootFromDOMContainer(continaer)`函数创建一个 root，并赋值给 `container._reactRootContainer`。如果存在，就继续向下执行。

3. 根据之前判断的`container._reactRootContainer`存在与否，这里采用不同的更新方式(Update)， 如果不存在，则使用`unbatchedUpdates`函数进行更新，否则直接更新。

**！！！这个更新是主线任务。不过我们先来看一下创建 Root**

#### `legacyCreateRootFromDOMContainer(continaer, forceHydrate)`

这个函数没啥看的。

1. 开发模式下会做一些校验

2. 通过`new ReactRoot(container, isConcurrent, shouldHydrate)`，创建一个 root 并返回。`isConcurrent`表示使用并发模式，在这里始终为`false`。`shouldHydrate`跟服务端渲染有关，也是`false`。

#### `new ReactRoot(container, isConcurrent, shouldHydrate)`

root 实例具有的属性及方法如下：

```javascript
function ReactRoot(container, isConcurrent, hydrate) {
  var root = createContainer(container, isConcurrent, hydrate);
  this._internalRoot = root;
}

/**
 * ！！主线更新将调用这个函数
 */
ReactRoot.prototype.render = function(children, callback) {
  var root = this._internalRoot;
  var work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(children, root, null, work._onCommit);
  return work;
};
ReactRoot.prototype.unmount = function(callback) {
  var root = this._internalRoot;
  var work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(null, root, null, work._onCommit);
  return work;
};
ReactRoot.prototype.legacy_renderSubtreeIntoContainer = function(
  parentComponent,
  children,
  callback
) {
  var root = this._internalRoot;
  var work = new ReactWork();
  callback = callback === undefined ? null : callback;
  if (callback !== null) {
    work.then(callback);
  }
  updateContainer(children, root, parentComponent, work._onCommit);
  return work;
};
ReactRoot.prototype.createBatch = function() {
  var batch = new ReactBatch(this);
  var expirationTime = batch._expirationTime;

  var internalRoot = this._internalRoot;
  var firstBatch = internalRoot.firstBatch;
  if (firstBatch === null) {
    internalRoot.firstBatch = batch;
    batch._next = null;
  } else {
    // Insert sorted by expiration time then insertion order
    var insertAfter = null;
    var insertBefore = firstBatch;
    while (
      insertBefore !== null &&
      insertBefore._expirationTime >= expirationTime
    ) {
      insertAfter = insertBefore;
      insertBefore = insertBefore._next;
    }
    batch._next = insertBefore;
    if (insertAfter !== null) {
      insertAfter._next = batch;
    }
  }

  return batch;
};
```

先来看构造函数中的 `createContainer`方法:

```javascript
//                                  false         false
function createContainer(container, isConcurrent, hydrate) {
  return createFiberRoot(container, isConcurrent, hydrate);
}
function createFiberRoot(container, isConcurrent, hydrate) {
  var uninitializedFiber = createHostRootFiber(isConcurrent);

  var root = {
    current: uninitializedFiber,
    containerInfo: container,
    pendingChildren: null,

    earliestPendingTime: NoWork,
    latestPendingTime: NoWork,
    earliestSuspendedTime: NoWork,
    latestSuspendedTime: NoWork,
    latestPingedTime: NoWork,

    pingCache: null,

    didError: false,

    pendingCommitExpirationTime: NoWork,
    finishedWork: null,
    timeoutHandle: noTimeout,
    context: null,
    pendingContext: null,
    hydrate: hydrate,
    nextExpirationTimeToWorkOn: NoWork,
    expirationTime: NoWork,
    firstBatch: null,
    nextScheduledRoot: null,
    // interaction => 交互    Thread => 线程   id
    interactionThreadID: tracing.unstable_getThreadID(),
    memoizedInteractions: new Set(),
    pendingInteractionMap: new Map()
  };

  uninitializedFiber.stateNode = root;

  return root;
}
```
